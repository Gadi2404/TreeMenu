EMC.routes.protection.gaps = function(elem, viewPath){
    "use strict";

    // Define DOM object
    var DOM = {
        scope : elem
    }

    /////////////////////////////////
    // DOM caching
    function populateDOM(){
        DOM.protectionGapsTable = DOM.scope.find('.protectionGapsTable');
        DOM.segmentsChartWrap   = DOM.scope.find('.segmentsChartWrap');
        DOM.protectionLevel     = DOM.scope.find('.protectionLevel');

        EMC.utilities.checkDOMbinding(DOM);
    };


    //////////////////////////////////////
    // Controller's components loader
    var componentsLoader = {
        protectionLevel : {
            init : function(){
                if( DOM.protectionLevel ){
                    // get the object needed for this page (from the main system data structure)
                    var pageData = EMC.utilities.getObjectByPath( EMC.state.protection, viewPath.slice(1, viewPath.length) );
                    EMC.components.protectionLevel(DOM.protectionLevel, pageData);
                }
            }
        },

        segmentsChart : {
            instance : null,
            data : null,
            init : function(res){
                componentsLoader.segmentsChart.data = transformData(res);
                componentsLoader.segmentsChart.instance = new EMC.components.SegmentsChart( DOM.segmentsChartWrap , componentsLoader.segmentsChart.data);
            }
        },

        table : {
            init : function(res){

                var categoryFilter = transformData(res).labels,
                    typeFilter     = transformData(res).types;

                // render table template
                var protectionGapsTable = $( EMC.tmpl("protection-gaps-table")({ items:res, typeFilter:typeFilter, categoryFilter:categoryFilter }) );

                // add the component's classes before replacing it
                protectionGapsTable.addClass( DOM.protectionGapsTable.attr('class') ); 

                // replace page component with real template
                DOM.protectionGapsTable.replaceWith(protectionGapsTable);
                // re-save DOM pointer with new DOM element generated by the template
                DOM.protectionGapsTable = protectionGapsTable;

                zebra();

                DOM.tableFilters = protectionGapsTable.find('.filter');

                //DOM.protectionGapsTable.parent().height( DOM.protectionGapsTable.height() );
                // sorting
                protectionGapsTable.stupidtable().on('aftertablesort', function(e, data) {
                    zebra();
                });
            }
        }
    };

    var events = {
        bind : function(){
            DOM.segmentsChartWrap.on('segmentClick', this.callbacks.onSegmentClick);
            DOM.protectionGapsTable.on('blur', ':checkbox', this.callbacks.onBlur )
                                   .on('click', '.dropDownMenu > a', this.callbacks.dropDownMenuClick );
        },

        callbacks : {
            onSegmentClick : function(e, value, state){
                filterTable(value, 2, state);

                var $dropDown = DOM.protectionGapsTable.find('th').eq(2).find('.dropDownMenu'),
                    $dropDownItem = $dropDown.find('a').filter(function(){
                        return $(this).data('filterBy').toLowerCase() == value.toLowerCase();
                    });

                resetDropDownFilters();

                toggleDropDownItemActive( $dropDown, $dropDownItem.index(), state );
            },

            onBlur : function(){
                var that = this;
                // set "checked" state of the input element to "false" so the dropdown menu will be hidden
                setTimeout(function(){
                    that.checked = false;
                }, 200);
            },

            dropDownMenuClick : function(){
                var $dropDownItem = $(this),
                    $dropDown     = $dropDownItem.closest('.dropDownMenu'),
                    idx           = $dropDownItem.closest('th').index(),
                    value         = $dropDownItem.data('filterBy'),
                    state         = !$dropDownItem.hasClass('active'); // set state according to the item's class (state must be "true" to enable filtering)

                 // toggle the state of the menu item via class
                toggleDropDownItemActive( $dropDown , $dropDownItem.index(), state, true );

                filterTable(value, idx, state);

                return false;
            }
        }
    }

    // get the URL path for the MOCK JSON file from an Array representing the path of the current view
    // ['aaa','bbb','ccc'] --> 'bbb.ccc'
    var url = viewPath.join('.');

    ///////////////////////////////////
    // Get server data
    $.ajax({
        type     : 'GET',
        url      : '/mocks/' + url +'.protection-gaps.txt',
        dataType : 'json'
    })
    .success(onSuccess)
    .fail(onFail);



    function onSuccess(res){
        // if res is undefined or null, or not an Array, or is an array with lenth `0`, do not continue.
        if( !res || !(res instanceof Array) || !res.length ){
            return;
        }

        populateDOM();

        for( let i in componentsLoader )
            componentsLoader[i].init(res);

        EMC.utilities.scriptsTemplates(DOM.scope);
        events.bind();
    }

    function onFail(){
        console.warn('fail');
    }



    // Mark every second tr element in the table which is visible
    function zebra(){
        DOM.protectionGapsTable.find('tr').removeClass('zebra').addBack().find('tr:visible:odd').addClass('zebra');
    }


    ////////////////////////////////////////
    // helper function

    // @filterBy - value of which to filter by
    // @state    - toggle filtering (should filter or not at all)
    function filterTable(filterBy, colIndex, state){
        if( !filterBy || !colIndex || !(typeof colIndex == 'number') ){
            console.warn('missing or wrong parameters');
            return false;
        }

        DOM.protectionGapsTable.find('> tbody > tr').each(function(){
            var $tr = $(this).removeAttr('style');

            if( state && $tr.find('td').eq(colIndex).text().toLowerCase() != filterBy.toLowerCase() )
                $tr.hide();
        })

        zebra();
    };

    function toggleDropDownItemActive(dropDown, itemIdx, state, setSegmentChart){
        var filterName   = dropDown.parent().data('name'),
            dropDownItem = dropDown.children().eq(itemIdx),
            itemValue    = dropDownItem.data('filterBy').toLowerCase(),
            segmentsChartItemIdx;

        if( setSegmentChart ){
            // case-insensetive indexOf
            for(let i in componentsLoader.segmentsChart.data.labels){
                if( componentsLoader.segmentsChart.data.labels[i].toLowerCase() == itemValue ){
                    segmentsChartItemIdx = +i;
                    break;
                }
            }

            // remove the "active" state of the segments chart component if any filter other than "category" was selected
            componentsLoader.segmentsChart.instance.cleanActive();

            if( filterName == 'category' && state && segmentsChartItemIdx != undefined )
                componentsLoader.segmentsChart.instance.activeStyles( segmentsChartItemIdx );
        }

        resetDropDownFilters();

        // set an "active" dropdown menu item
        dropDownItem.toggleClass('active', state).siblings().removeClass('active');
        // toggle the "active" class of the dropdown container itself
        dropDown.parent().toggleClass('active', state);
    };

    // cleanup - remove all "active" classes from all the filters' dropdown menus
    function resetDropDownFilters(){
        DOM.tableFilters.each(function(){
            $(this).removeClass('active').find('a').removeClass('active');
        });
    }

    // transforms JSON data into the segment chart data
    var transformData = (function(){
        var transformDataRes;

        return function(data){
            if( transformDataRes )
                return transformDataRes;

            var categoryTypes = {},
                dataset = [],
                types = [];

            //data.map( item => item.category );
            data.forEach(function(item){
                var itemType = item.type.toLowerCase();
                if( types.indexOf(itemType) == -1 )
                    types.push(itemType);
                if( !categoryTypes[item.category] ){
                    categoryTypes[item.category] = 1;
                    dataset.push(1); // make sure each value of the dataset is the same, so their sizes will be rendered equaliy by pushing the same value (doesn't matter which value)
                }
                else
                    categoryTypes[item.category]++;
            });

            transformDataRes = {
                labels   : Object.keys(categoryTypes),
                dataset  : dataset,
                valueset : _.map(categoryTypes),
                types    : types
            };

            return transformDataRes;
        }
    })();
};